/*----------------------------------------------------------------------------
 *      
 *----------------------------------------------------------------------------
 *      Name:    BUTTONS.H
 *      Purpose: Microprocessors Laboratory
 *----------------------------------------------------------------------------
 *      
 *      Author: Pawel Russek AGH University of Science and Technology
 *			
 * 	BORROWED FILE TO HANDLE THE SNAKE
 *  The changes were made by 
 *	Kamil Gierlach and Karol Piech
 *---------------------------------------------------------------------------*/

#include "lcd.h"
#include "buttons.h"
#include "snake.h"

/*Iniatlize variable*/
typedef enum{ BUT1 = 1, BUT2 = 2, BUT3} ButtonType;
static uint8_t PAUSE = 1; //0 -> pause, 1 -> start
static uint8_t RESET = 0; // 1 -> reset
static uint8_t name = 0; 
static uint8_t incorrect = 0;
static uint8_t correct = 1;
static uint8_t highscore_but = 0;


/*Number of IRQ generated by PORTC_PORTD interrupt*/
static const IRQn_Type myPORT_IRQn =  31;  	/* Define interrupt (IRQ) number for PORTB. Check MKL05Z4 or find in NVIC section of KL05 Sub-Family Reference Manual - NVIC section */ 


void PORTB_IRQHandler(void)									/* Put a proper name of PORTB Interrupt service routine ISR. See system_MKL05Z4.s file for function name */ 
{
	if(correct == 1) //player name
	{
		//set name button
		if( PORTB->ISFR & (1 << BUT1) ){          /* Check in ISFR register if button BUT1 is pressed */
			name = 1;
			while((FPTB->PDIR&(1<<BUT1))==0);				/* Enable wait in the interrupt for SW1 button release */	
			PORTB->PCR[BUT1] |= (1<<24);					  /* Make sure that interrupt service flag (ISF) in Port Control Register is cleared during ISR execution */
		}
		//correct button
		if( PORTB->ISFR & (1 << BUT2) ){          
			correct = 0;
			while((FPTB->PDIR&(1<<BUT2))==0);				
			PORTB->PCR[BUT2] |= (1<<24); 
		}
		//incorrect button
		if( PORTB->ISFR & (1 << BUT3) ){          
			incorrect = 1;
			while((FPTB->PDIR&(1<<BUT3))==0);				
			PORTB->PCR[BUT3] |= (1<<24); 
		}
	}
	else if(correct == 0) //game
	{
		if(get_game_over()) //game over -> display high score 
		{
			if(highscore_but == 1) //new player -> written nickname
			{
				if( PORTB->ISFR & (1 << BUT2) )
				{
					correct = 1;
					set_high_but(0);
					
					while((FPTB->PDIR&(1<<BUT2))==0);	
					PORTB->PCR[BUT2] |= (1<<24); 
				}
			}
			else  // display highscore 
			{
				if( PORTB->ISFR & (1 << BUT2) )
				{
					set_high_but(1);	
					
					while((FPTB->PDIR&(1<<BUT2))==0);	
					PORTB->PCR[BUT2] |= (1<<24); 
				}
			}
		}
		
			//reset button -> new game, same player
		if( PORTB->ISFR & (1 << BUT1) )  /* Check in ISFR register if button BUT1 is pressed */
		{         
			set_reset(1);
			
			while((FPTB->PDIR&(1<<BUT1))==0);				/* Enable wait in the interrupt for SW1 button release */	
			PORTB->PCR[BUT1] |= (1<<24);					  /* Make sure that interrupt service flag (ISF) in Port Control Register is cleared during ISR execution */
		}
		else if(highscore_but == 0) 
		{
		if( PORTB->ISFR & (1 << BUT2) ){   //pause and start during game  
			if(PAUSE)
			{
					//pause
					set_pause(0);
			}
			else 
			{
					//start
					set_pause(1);
			}
			while((FPTB->PDIR&(1<<BUT2))==0);	
			PORTB->PCR[BUT2] |= (1<<24); 
		}
		}
	}
	
}



//getters and setters
uint8_t get_pause()
{
	return PAUSE;
}

uint8_t get_high_but()
{
	return highscore_but;
}

void set_high_but(uint8_t h)
{
	highscore_but = h;
}

uint8_t get_reset()
{
	return RESET;
}

//setter
void set_pause(uint8_t p)
{
	PAUSE = p;
}

void set_reset(uint8_t p)
{
	RESET = p;
}

uint8_t name_button()
{
	return name;
}

void set_v_name(uint8_t i)
{
	name = i;
}

uint8_t correct_button()
{
	return correct;
}

void set_v_correct(uint8_t i)
{
	correct = i;
}

uint8_t incorrect_button()
{
	return incorrect;
}

void set_v_incorrect(uint8_t i)
{
	incorrect = i;
}




void buttonsInitialize(void){
	SIM->SCGC5 |=  SIM_SCGC5_PORTB_MASK; 				/* Enable clock for port B */
	PORTB->PCR[BUT1] |= PORT_PCR_MUX(1);      	/* Pin PTB0 is GPIO */
	PORTB->PCR[BUT2] |= PORT_PCR_MUX(1);      	/* Pin PTB1 is GPIO */
	PORTB->PCR[BUT3] |= PORT_PCR_MUX(1);      	/* Pin PTB5 is GPIO */

	
	/* Port control register for bit 3 of port C configuration. Activate pull up and interrupt */
	PORTB->PCR[BUT1] |= (1<<1);			/* Set PE bit in PCR register to enable pull resistor. See KL05 Sub-Family Reference Manual */
	PORTB->PCR[BUT1] |= (1<<0);			/* Set PS bit in PCR register to select pull up. See KL05 Sub-Family Reference Manual */
	PORTB->PCR[BUT1] |= (1<<19);		/* Set value for IRQC bit field in PCR register to select rising edge interrupts for PORTB. See KL05 Sub-Family Reference Manual */
	PORTB->PCR[BUT1] |= (0<<18);
	PORTB->PCR[BUT1] |= (1<<17);
	PORTB->PCR[BUT1] |= (0<<16);
	
	PORTB->PCR[BUT2] |= (1<<1);			/* Set PE bit in PCR register to enable pull resistor. See KL05 Sub-Family Reference Manual */
	PORTB->PCR[BUT2] |= (1<<0);			/* Set PS bit in PCR register to select pull up. See KL405 Sub-Family Reference Manual */
	PORTB->PCR[BUT2] |= (1<<19);	  /* Set value for IRQC bit field in PCR register to select falling edge interrupts for PORTB. See KL05 Sub-Family Reference Manual */
	PORTB->PCR[BUT2] |= (0<<18);
	PORTB->PCR[BUT2] |= (1<<17);
	PORTB->PCR[BUT2] |= (0<<16);
	
	PORTB->PCR[BUT3] |= (1<<1);			/* Set PE bit in PCR register to enable pull resistor. See KL05 Sub-Family Reference Manual */
	PORTB->PCR[BUT3] |= (1<<0);			/* Set PS bit in PCR register to select pull up. See KL405 Sub-Family Reference Manual */
	PORTB->PCR[BUT3] |= (1<<19);	  /* Set value for IRQC bit field in PCR register to select falling edge interrupts for PORTB. See KL05 Sub-Family Reference Manual */
	PORTB->PCR[BUT3] |= (0<<18);
	PORTB->PCR[BUT3] |= (1<<17);
	PORTB->PCR[BUT3] |= (0<<16);
		
	/* ARM's Nested Vector Interrupt Controller configuration */
	NVIC_ClearPendingIRQ(myPORT_IRQn);				/* Clear NVIC any pending interrupts on PORTC_B */
	NVIC_EnableIRQ(myPORT_IRQn);							/* Enable NVIC interrupts source for PORTC_B module */
	NVIC_SetPriority (myPORT_IRQn, 3);				/* Set POR_B interrupt priority level  */ 
}


